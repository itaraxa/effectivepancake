# Задание по треку «Сервис сбора метрик и алертинга»
## Инкремент 1
Разработайте сервер для сбора рантайм-метрик, который будет собирать репорты от агентов по протоколу HTTP. Агент вам предстоит реализовать в следующем инкременте — в качестве источника метрик вы будете использовать пакет runtime.
Сервер должен быть доступен по адресу `http://localhost:8080`, а также:

- Принимать и хранить произвольные метрики двух типов:
    - Тип gauge, float64 — новое значение должно замещать предыдущее.
    - Тип counter, int64 — новое значение должно добавляться к предыдущему, если какое-то значение уже было известно серверу.
- Принимать метрики по протоколу HTTP методом POST.
- Принимать данные в формате http://<АДРЕС_СЕРВЕРА>/update/<ТИП_МЕТРИКИ>/<ИМЯ_МЕТРИКИ>/<ЗНАЧЕНИЕ_МЕТРИКИ>, Content-Type: text/plain.
- При успешном приёме возвращать http.StatusOK.
- При попытке передать запрос без имени метрики возвращать http.StatusNotFound.
- При попытке передать запрос с некорректным типом метрики или значением возвращать http.StatusBadRequest.

Редиректы не поддерживаются.
Для хранения метрик объявите тип MemStorage. Рекомендуем использовать тип struct с полем-коллекцией внутри (slice или map). В будущем это позволит добавлять к объекту хранилища новые поля, например логер или мьютекс, чтобы можно было использовать их в методах. Опишите интерфейс для взаимодействия с этим хранилищем.
Пример запроса к серверу:

```
POST /update/counter/someMetric/527 HTTP/1.1
Host: localhost:8080
Content-Length: 0
Content-Type: text/plain
```

Пример ответа от сервера:

```
HTTP/1.1 200 OK
Date: Tue, 21 Feb 2023 02:51:35 GMT
Content-Length: 11
Content-Type: text/plain; charset=utf-8
```

## Инкремент 3
Вы написали приложение с помощью пакета стандартной библиотеки `net/http`. Используя любой внешний пакет (роутер или фреймворк), совместимый с `net/http`, перепишите ваш код:

- Доработайте сервер так, чтобы в ответ на запрос `GET http://<АДРЕС_СЕРВЕРА>/value/<ТИП_МЕТРИКИ>/<ИМЯ_МЕТРИКИ>` он возвращал текущее значение метрики в текстовом виде со статусом `http.StatusOK`.
- При попытке запроса неизвестной метрики сервер должен возвращать `http.StatusNotFound`.
- По запросу `GET http://<АДРЕС_СЕРВЕРА>/` сервер должен отдавать HTML-страницу со списком имён и значений всех известных ему на текущий момент метрик.
- Хендлеры должны взаимодействовать с экземпляром MemStorage при помощи соответствующих интерфейсных методов.

# Инкремент 4
Доработайте код, чтобы он умел принимать аргументы с использованием флагов.
- Аргументы сервера:
  - Флаг `-a=<ЗНАЧЕНИЕ>` отвечает за адрес эндпоинта HTTP-сервера (по умолчанию `localhost:8080`).
- При попытке передать приложению незвестные флаги оно должно завершаться с сообщением о соответствующей ошибке.
- Значения интервалов времени должны задаваться в секундах.
- Во всех случаях должны присутствовать значения по умолчанию.

# Инкремент 5
Доработайте сервер, чтобы он мог изменять свои параметры запуска по умолчанию через переменные окружения:
- `ADDRESS` отвечает за адрес эндпоинта HTTP-сервера.
- Приоритет параметров должен быть таким:
    - Если указана переменная окружения, то используется она.
    - Если нет переменной окружения, но есть аргумент командной строки (флаг), то используется он.
    - Если нет ни переменной окружения, ни флага, то используется значение по умолчанию.

# Инкремент 6
Реализуйте логирование сведений о запросах и ответах на сервере для всех эндпоинтов, которые у вас уже есть. 
- Сведения о запросах должны содержать URI, метод запроса и время, затраченное на его выполнение.
- Сведения об ответах должны содержать код статуса и размер содержимого ответа.
Эту функциональность нужно реализовать через middleware. Используйте один из сторонних пакетов для логирования:
- [zerolog](github.com/rs/zerolog),
- [zap](go.uber.org/zap),
- [logrus](github.com/sirupsen/logrus).

Все сообщения логера должны быть на уровне `Info`.

# Инкремент 7
Дополните API сервера, чтобы позволить ему принимать метрики в формате JSON.
При реализации задействуйте одну из распространённых библиотек:
- encoding/json,
- github.com/mailru/easyjson,
- github.com/pquerna/ffjson.
- github.com/labstack/echo.
Обмен с сервером организуйте с использованием следующей структуры:

```Go
type Metrics struct {
    ID    string   `json:"id"`              // имя метрики
    MType string   `json:"type"`            // параметр, принимающий значение gauge или counter
    Delta *int64   `json:"delta,omitempty"` // значение метрики в случае передачи counter
    Value *float64 `json:"value,omitempty"` // значение метрики в случае передачи gauge
} 
```

Для передачи метрик на сервер используйте Content-Type: `application/json`. В теле запроса должен быть описанный выше JSON. Передавать метрики нужно через `POST` `update/`. В теле ответа отправляйте JSON той же структуры с актуальным (изменённым) значением Value. 
Для получения метрик с сервера также используйте Content-Type: `application/json`. В теле запроса должен быть описанный выше JSON с заполненными полями ID и MType. Запрашивать нужно через `POST` `value/`. В теле ответа должен приходить такой же JSON, но с уже заполненными значениями метрик. 
Переведите агент на новый API.
Автотесты проверяют, что агент экспортирует и обновляет на сервере метрики, описанные в первых инкрементах.

# Инкремент 8
Добавьте поддержку **gzip** в код сервера и агента. Научите:
- Сервер опционально принимать запросы в сжатом формате (при наличии соответствующего HTTP-заголовка `Content-Encoding`).
- Отдавать сжатый ответ клиенту, который поддерживает обработку сжатых ответов (с HTTP-заголовком `Accept-Encoding`).
Функция сжатия должна работать для контента с типами `application/json` и `text/html`.
Вспомните middleware из урока про HTTP-сервер, это может вам помочь.

# Инкремент 9
Доработайте код сервера, чтобы он мог с заданной периодичностью сохранять текущие значения метрик на диск в указанный файл, а на старте — опционально загружать сохранённые ранее значения. При штатном завершении сервера все накопленные данные должны сохраняться. Сервер должен принимать соответствующие параметры конфигурации через флаги и переменные окружения:
- Флаг `-i`, переменная окружения `STORE_INTERVAL` — интервал времени в секундах, по истечении которого текущие показания сервера сохраняются на диск (по умолчанию 300 секунд, значение 0 делает запись синхронной).
- Флаг `-f`, переменная окружения `FILE_STORAGE_PATH` — путь до файла, куда сохраняются текущие значения. Имя файла для значения по умолчанию придумайте сами.
- Флаг `-r`, переменная окружения `RESTORE` — булево значение (**true**/**false**), определяющее, загружать или нет ранее сохранённые значения из указанного файла при старте сервера (по умолчанию true).

Приоритет параметров сервера должен быть таким:

1. Если указана переменная окружения, то используется она.
2. Если нет переменной окружения, но есть флаг, то используется он.
3. Если нет ни переменной окружения, ни флага, то используется значение по умолчанию.
# Задание по треку «Сервис сбора метрик и алертинга»
# Приложение **agent**
## Инкремент 2
Разработайте агент (HTTP-клиент) для сбора рантайм-метрик и их последующей отправки на сервер по протоколу HTTP.
Агент должен собирать метрики двух типов:
- Тип gauge, float64.
- Тип counter, int64.

В качестве источника метрик используйте пакет runtime.
Нужно собирать следующие метрики типа gauge:
- Alloc
- BuckHashSys
- Frees
- GCCPUFraction
- GCSys
- HeapAlloc
- HeapIdle
- HeapInuse
- HeapObjects
- HeapReleased
- HeapSys
- LastGC
- Lookups
- MCacheInuse
- MCacheSys
- MSpanInuse
- MSpanSys
- Mallocs
- NextGC
- NumForcedGC
- NumGC
- OtherSys
- PauseTotalNs
- StackInuse
- StackSys
- Sys
- TotalAlloc

К метрикам пакета runtime добавьте ещё две:
- PollCount (тип **counter**) — счётчик, увеличивающийся на 1 при каждом обновлении метрики из пакета runtime (на каждый `pollInterval` — см. ниже).
- RandomValue (тип **gauge**) — обновляемое произвольное значение.

По умолчанию приложение должно:
- Обновлять метрики из пакета `runtime` с заданной частотой: `pollInterval` — 2 секунды.
- Отправлять метрики на сервер с заданной частотой: `reportInterval` — 10 секунд.

Чтобы приостанавливать работу функции на заданное время, используйте вызов `time.Sleep(n * time.Second)`. Подробнее о пакете time и его возможностях вы узнаете в третьем спринте.
Метрики нужно отправлять по протоколу HTTP методом POST:
- Формат данных — `http://<АДРЕС_СЕРВЕРА>/update/<ТИП_МЕТРИКИ>/<ИМЯ_МЕТРИКИ>/<ЗНАЧЕНИЕ_МЕТРИКИ>`.
- Адрес сервера — `http://localhost:8080`.
- Заголовок — `Content-Type: text/plain`.

Пример запроса к серверу:
```
POST /update/counter/someMetric/527 HTTP/1.1
Host: localhost:8080
Content-Length: 0
Content-Type: text/plain
```
Пример ответа от сервера:
```
HTTP/1.1 200 OK
Date: Tue, 21 Feb 2023 02:51:35 GMT
Content-Length: 11
Content-Type: text/plain; charset=utf-8
```

Покройте код агента и сервера юнит-тестами.

# Инкремент 4
Доработайте код, чтобы он умел принимать аргументы с использованием флагов.
- Аргументы агента:
  - Флаг `-a=<ЗНАЧЕНИЕ>` отвечает за адрес эндпоинта HTTP-сервера (по умолчанию `localhost:8080`).
  - Флаг `-r=<ЗНАЧЕНИЕ>` позволяет переопределять `reportInterval` — частоту отправки метрик на сервер (по умолчанию 10 секунд).
  - Флаг `-p=<ЗНАЧЕНИЕ>` позволяет переопределять `pollInterval` — частоту опроса метрик из пакета runtime (по умолчанию 2 секунды).
- При попытке передать приложению неизвестные флаги оно должно завершаться с сообщением о соответствующей ошибке.
- Значения интервалов времени должны задаваться в секундах.
- Во всех случаях должны присутствовать значения по умолчанию.

# Инкремент 5
Доработайте агент, чтобы он мог изменять свои параметры запуска по умолчанию через переменные окружения:
- `ADDRESS` отвечает за адрес эндпоинта HTTP-сервера.
- `REPORT_INTERVAL` позволяет переопределять `reportInterval`.
- `POLL_INTERVAL` позволяет переопределять `pollInterval`.
- Значения интервалов времени должны задаваться в секундах.

# Инкремент 7
Для передачи метрик на сервер используйте Content-Type: `application/json`. В теле запроса должен быть описанный выше JSON. Передавать метрики нужно через `POST` `update/`. В теле ответа отправляйте JSON той же структуры с актуальным (изменённым) значением Value. 
Для получения метрик с сервера также используйте Content-Type: `application/json`. В теле запроса должен быть описанный выше JSON с заполненными полями ID и MType. Запрашивать нужно через `POST` `value/`. В теле ответа должен приходить такой же JSON, но с уже заполненными значениями метрик. 
Переведите агент на новый API.
Автотесты проверяют, что агент экспортирует и обновляет на сервере метрики, описанные в первых инкрементах.

# Инкремент 8
Добавьте поддержку **gzip** в код сервера и агента. Научите:
- Агент передавать данные в формате **gzip**.
Функция сжатия должна работать для контента с типами `application/json` и `text/html`.

# Инкремент 12
Агент:
- Научите агент работать с использованием нового API (отправлять метрики батчами).
Стоит помнить, что:
- нужно соблюдать обратную совместимость;
- отправлять пустые батчи не нужно;
- вы умеете сжимать контент по алгоритму gzip;
- изменение в базе можно выполнять в рамках одной транзакции или одного запроса;
- необходимо избегать формирования условий для возникновения состояния гонки (race condition).

# Инкремент 13
Измените весь свой код в соответствии со знаниями, полученными в этой теме. Добавьте обработку **retriable-ошибок**.
**Retriable-ошибки** — это ошибки, которые могут быть исправлены повторной попыткой выполнения операции. Это бывает полезно для программ, которые работают с сетью или файловой системой, где возможны временные проблемы связи или доступа к данным. Ошибки могут быть вызваны различными причинами, такими как перегрузка сервера, недоступность сети или ошибки в коде программы.
Примеры **retriable-ошибок**:
- Ошибка связи с сервером при отправке запроса.

Сценарии возможных ошибок:
- Агент не сумел с первой попытки выгрузить данные на сервер из-за временной невозможности установить соединение с сервером.

Стратегия реализации:
- Количество повторов должно быть ограничено тремя дополнительными попытками.
- Интервалы между повторами должны увеличиваться: `1s`, `3s`, `5s`.

# Инкремент 14
Реализуйте механизм подписи передаваемых данных по алгоритму `SHA256`. Для этого посчитайте hash от всего тела запроса и разместите его в **HTTP**-заголовке `HashSHA256`.
Хеш нужно считать от строки с учётом ключа, который передан агенту/серверу на старте: `hash(value, key)`.
Агент:
- Добавьте поддержку аргумента через флаг `-k=<КЛЮЧ>` и переменную окружения K`EY=<КЛЮЧ>`.
- При наличии ключа агент должен вычислять хеш и передавать в **HTTP**-заголовке запроса с именем `HashSHA256`.
